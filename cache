#include <stdio.h>
#include <math.h>

#define WORD_SIZE_BYTE 4 // 1 word = 4 bytes
#define DEFAULT_CACHE_SIZE_BYTE 32 // cache size = 32 bytes
#define DEFAULT_CACHE_BLOCK_SIZE_BYTE 8 // block size = 8 bytes
#define DEFAULT_CACHE_ASSOC 4// association = 2
// direct 1, 2-way 2, fully 4
#define DEFAULT_MEMORY_SIZE_WORD 128 // main memory size = 128 words
// = 128 * 4 bytes
#define CACHE_ACCESS_CYCLE 1 // cache access time = 1 cycle
#define MEMORY_ACCESS_CYCLE 100 // main memory access time
// = 100 cycles
#define CACHE_SET_SIZE ((DEFAULT_CACHE_SIZE_BYTE) / (DEFAULT_CACHE_BLOCK_SIZE_BYTE * DEFAULT_CACHE_ASSOC))
// set size=[direct]32/(8*1)=4, [2-way]32/(8*2)=2, [full] 32/(8*4)=1

/* Function Prototypes */
void init_memory_content();
void init_cache_content();
void print_cache_entries();
void func(void* x, char type);
int check_cache_data_hit(void* addr, char type);
int access_memory(void* addr, char type);
int retrieve_data(void* addr, char data_type);
/* Cache Entry Structure */

typedef struct cache_entry {
	int valid; // present = 1, not present = 0
	int tag; // tag of the stored data
	int timestamp; // most recent access time
	char data[DEFAULT_CACHE_BLOCK_SIZE_BYTE]; // data from memory[address]
} cache_entry_t; // define type as cache_entry_t

/* hit ratio = (num_cache_hits / (num_cache_hits + num_cache_misses)) */
int num_cache_hits = 0; // # of hits
int num_cache_misses = 0; // # of misses

/* bandwidth = (num_bytes / num_acess_cycles) */
int num_bytes = 0; // # of accessed bytes
int num_access_cycles = 0;// # of clock cycles
int global_timestamp = 0; // # of data access trial

FILE* ifp = NULL, * ofp = NULL; // file pointers

unsigned long int access_addr[8]={334,490,329,489,338,279,148,339}; // byte address (located at 1st column)
char access_type[8]={'b','h','w','h','h','b','w','b'}; // 'b'(byte), 'h'(halfword), or 'w'(word)
// (located at 2nd column)
int accessed_data; // data to retrive
/* initialize memory and cache
by invoking init_memory_content() and init_cache_content() */

cache_entry_t cache_array[CACHE_SET_SIZE][DEFAULT_CACHE_ASSOC];
int memory_array[DEFAULT_MEMORY_SIZE_WORD];

int main() {
	init_memory_content();
	init_cache_content();
	/* open input file as reading mode */
	//여기 부분은 skip할게 너가 해주라~ㅋㅋ
	/*ifp = fopen("access_input.txt", "r");
	if (ifp == NULL) {
		printf("Can't open input file\n");
		return -1;
	}
	open output file as writing mode
	ofp = fopen("access_output.txt", "w");
	if (ofp == NULL) {
		printf("Can't open output file\n");
		fclose(ifp);
		return -1;
	}
	*/
	for(int i=0;i<8;i++){
	printf("===== addr %ld type %c =====\n",access_addr[i] ,access_type[i]);
	/* read each line and get the data in given (address, type)
	by invoking retrieve_data() */
	global_timestamp++;
	accessed_data=retrieve_data(access_addr+i,access_type[i]);
	printf("0x%x\n",accessed_data);
	if(access_type[i]=='b') num_bytes++;
	else if(access_type[i]=='h') num_bytes+=2;
	else num_bytes+=4;
	//func(&accessed_data,access_type[i]);
	/* print hit ratio and bandwidth for each cache mechanism
	as regards to cache association size */

	/* close files */
//	fclose(ifp);
//	fclose(ofp);

	/* print the final cache entries by invoking print_cache_entries() */
	print_cache_entries();
	printf("\n");
	}	
	float hit_ratio=(float)num_cache_hits / (num_cache_hits + num_cache_misses);
	float bandwidth=(float)num_bytes / num_access_cycles;
	printf("hit ratio = %.2f (%d / %d)\nbandwidth = %.2f (%d / %d)\n",
	hit_ratio,num_cache_hits,(num_cache_hits + num_cache_misses),
	bandwidth,num_bytes,num_access_cycles);
	return 0;
}
void func(void* x, char type) {
   if (type == 'b')
      printf("%#x\n", (char*)x);
   else if (type == 'h')
      printf("%#x\n", (short*)x);
   else if (type == 'w')
      printf("%#x\n", (int*)x);
}
void init_memory_content() {
	unsigned char sample_upward[16] = { 0x001, 0x012, 0x023, 0x034, 0x045, 0x056,
	0x067, 0x078, 0x089, 0x09a, 0x0ab, 0x0bc, 0x0cd, 0x0de, 0x0ef };
	unsigned char sample_downward[16] = { 0x0fe, 0x0ed, 0x0dc, 0x0cb, 0x0ba,
	0x0a9, 0x098, 0x087, 0x076, 0x065, 0x054, 0x043, 0x032, 0x021, 0x010 };
	int index, i = 0, j = 1, gap = 1;
	printf("DATA >>\n");

	for (index = 0; index < DEFAULT_MEMORY_SIZE_WORD; index++) { //128
		printf(" [i = %d, j = %d, gap = %d] ", i, j, gap);
		memory_array[index] = (sample_upward[i] << 24) | (sample_upward[j] << 16) // 1word = 4 bytes = 4 *8bit= 32bits
			| (sample_downward[i] << 8) | (sample_downward[j]);
		if (++i >= 16) i = 0; // cycle
		if (++j >= 16) j = 0; // cycle
		if (i == 0 && j == i + gap) // difference of i and j == gap
			j = i + (++gap); // increases 1 gap and new j for each cycle
		printf("\tmem[%d] = %#x\n", index, memory_array[index]);
	}
	printf("\n\n");
}
/* 초기화 cache memory */
void init_cache_content() {
	int i, j;
	/* initialize cache data */
	for (i = 0; i < CACHE_SET_SIZE; i++) {
		for (j = 0; j < DEFAULT_CACHE_ASSOC; j++) {
			cache_entry_t* pEntry = &cache_array[i][j];
			pEntry->valid = 0; // invalid
			pEntry->tag = -1; // no tag
			pEntry->timestamp = 0; // no access trial
		}
	}
}
/* 캐시 출력 */
void print_cache_entries() {
	int i, j, k;
	printf("ENTRY >>\n");
	// for each set
	for (i = 0; i < CACHE_SET_SIZE; i++) {
		printf(" [Set %d] ", i);
		// for each entry in a set
		for (j = 0; j < DEFAULT_CACHE_ASSOC; j++) {
			cache_entry_t* pEntry = &cache_array[i][j];
			printf("\n Valid: %d Tag: %#x Time: %d Data: ", pEntry->valid,
				pEntry->tag, pEntry->timestamp);
			// for each block in a entry
			for (k = 0; k < DEFAULT_CACHE_BLOCK_SIZE_BYTE; k++) {
				printf("(%d)%#x ", k, pEntry->data[k]);
			}
			printf("\t");
		}
		printf("\n");
	}
}

int check_cache_data_hit(void* addr, char type) {
	int * n = addr; // addr = access_addr;
	int tag = floor(*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE) /  CACHE_SET_SIZE;
	int index = (int)floor(*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE) %  CACHE_SET_SIZE;

	printf("CACHE >> block_addr = %d, byte_offset = %d, cache_index = %d, tag = %d\n",
		*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE,  //block_addr
		*n % DEFAULT_CACHE_BLOCK_SIZE_BYTE, //byte_offset
		index, // cache_index
		tag //tag
	);
	/* add this cache access cycle to global access cycle */
	num_access_cycles++;

	/* check all entries in a set */
	
		for (int j = 0; j < DEFAULT_CACHE_ASSOC; j++) {
			cache_entry_t* pEntry = &cache_array[index][j];
			if (pEntry->valid == 1 && tag == pEntry->tag) {  //valid =1 이고, tag가 일치하면 hit, 나머지는 miss
				printf("=> Hit!\n");
				num_cache_hits++;
				return pEntry->data[j];
			}
		}
	printf("=> Miss!\n");
	num_cache_misses++;
	// return -1 for missing
	return -1;
}
int find_entry_index_in_set(int cache_index) {
	int entry_index;

	/* If the set has only 1 entry, return index 0 */
	if (DEFAULT_CACHE_ASSOC == 1) return 0;
	/* Check if there exists any empty cache space by checking 'valid' */
	for (int j = 0; j < DEFAULT_CACHE_ASSOC; j++) {
		cache_entry_t* pEntry = &cache_array[cache_index][j];
		if (pEntry->valid == 1)  continue;
		return j;
	}
	/* Otherwise, search over all entries to find the least recently used entry by checking 'timestamp' */
	int temp = 10000000000;
	for (int j = 0; j < DEFAULT_CACHE_ASSOC; j++) {
		cache_entry_t* pEntry = &cache_array[cache_index][j];
		if (pEntry->timestamp < temp) { //최소 timestamp값 구하기
			temp = pEntry->timestamp;
			entry_index = j;
		}
	}
	return entry_index;
}

int access_memory(void* addr, char type) { //miss -> copy
	/* get the entry index by invoking find_entry_index_in_set()
	for copying to the cache */
	int data=0;
	int *n=addr;
	int cache_index=(int)floor(*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE) %  CACHE_SET_SIZE;
	int entry_index = find_entry_index_in_set(cache_index);
	/* add this main memory access cycle to global access cycle */
	num_access_cycles += 100;
	/* Fetch the data from the main memory and copy them to the cache */
	
	cache_entry_t* pEntry = &cache_array[cache_index][entry_index];
	pEntry->valid = 1;
	pEntry->tag = floor(*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE) /  CACHE_SET_SIZE;
	pEntry->timestamp= global_timestamp;

	int word_index = floor(*n / DEFAULT_CACHE_BLOCK_SIZE_BYTE) * DEFAULT_CACHE_BLOCK_SIZE_BYTE / WORD_SIZE_BYTE;
	printf("MEMORY >> word index = %d\n",word_index);
	//Floor(Byte Address / Block Size) X Block Size / Word Size
	int right_shift = 8; // 1byte = 8bits
	int val = memory_array[word_index];
	
	for (int i = 0; i < DEFAULT_CACHE_BLOCK_SIZE_BYTE-4; i++) {
		pEntry->data[i] = val;
		val=val >> right_shift; //1 byte right shift
	}
	val = memory_array[word_index + 1];
	for (int i = 4; i < DEFAULT_CACHE_BLOCK_SIZE_BYTE ; i++) {
		pEntry->data[i] = val;
		val=val >> right_shift; //1 byte right shift
	}
	//copy done
    int byte_offset=*n % DEFAULT_CACHE_BLOCK_SIZE_BYTE;
	switch (type) {
		case 'b':
			data=pEntry->data[byte_offset];
			break;
		case 'h':
			data=(pEntry->data[byte_offset+1]<<8)|(pEntry->data[byte_offset]&255);
			break;
		case 'w':
			data=(pEntry->data[byte_offset]&255)
			|((pEntry->data[byte_offset+1]&255)<<8)
			|((pEntry->data[byte_offset+2]&255)<<16)
			|(pEntry->data[byte_offset+3]<<24);
			break;
		
		default : return -1;
	}
	// return -1 for unknown type
	return data;
}

int retrieve_data(void* addr, char data_type) {
   int value_returned = -1; /* accessed data */
  
   /* Check data by invoking check_cache_data_hit() */
   int check=check_cache_data_hit(addr, data_type);
   if (check==-1) {
   /* In case of the cache miss event, retrieve data from the main memory
   by invoking access_memory() */
      value_returned = access_memory(addr,data_type);
      if (value_returned == -1) { 
         printf("UNKNOWN TYPE");
         return -1;
      }
   }
   else value_returned=check;
   /* If there is no data neither in cache nor memory, return -1,
   else return data */
   return value_returned;
}
